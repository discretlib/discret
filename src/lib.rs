//! Discret: Create local first, peer to peer application (P2P) using a GraphQL inspired API
//!
//!
//! Creating an application requires a few steps
//!  - Create a datamodel that contains the entity that will be synchronized
//!  - Create rooms to manage access rights to the data
//!  - Add data to the rooms
//!  - Create invitation to your rooms and manually send them to who you want via external application like email
//!  - Once the peer accept the invitaion it will start synchronising data it is allowed to access.
//!
//! Discret hides the complexity of peer to peer networks and reduces it to a database synchronisation problem.
//! Compared to traditional application, most of the new complexity resides in the Room rights managements.
//! Depending on the rights you choose, Rooms can have many different use cases.
//!
//! As data lives on your devices, Discret should only be used for applications with data generated by "real person", with hundreds of peers at most.
//! It is not suited for large scale application and communities with thousands of peoples.
//! It currenlty only support text data but support for external file synchronisation is planned.
//!
//! On local network, peer connection happens without requiring any server.
//! For peer to peer connection over the Internet, a discovery server is needed to allow peers to discover each others. The discret lib provides an implementation of the discovery server named Beacon.
//! Connection over the internet is not 100% guaranted to work, because certain types of enterprise firewalls will block the connection attempts.
//! The library support both IPv6 and IPv4
//!
//! The library provides strong security features out of the box:
//!     - data is encrypted at rest by using the SQLCipher database
//!     - encrypted communication using the QUIC protocol
//!     - data integrity: each rows is signed with the peer signing key, making it very hard to synchronise bad data
//!     - access control via Rooms
//!
//! Please, be warned that P2P connections leaks your IP adress and should only be used with trusted peer.
//! This leak exposes you to the following threats:
//!     - Distributed denial of service (DDOS)
//!     - Leak of your "Real World" location via geolocation services.
//!     - State sponsored surveillance: A state watching the network could determine which peer connect to which, giving a lot of knowledge about your social network.
//!
//!
#![forbid(unsafe_code)]
#![allow(dead_code)]

mod configuration;
mod database;
mod date_utils;
mod event_service;
mod log_service;
mod network;
mod peer_connection_service;
mod security;
mod signature_verification_service;
mod synchronisation;

use database::graph_database::GraphDatabaseService;
use database::mutation_query::MutationQuery;
use event_service::EventService;

use peer_connection_service::{PeerConnectionMessage, PeerConnectionService};
use security::{default_uid, derive_key, uid_decode, uid_encode, MeetingSecret, Uid};

use signature_verification_service::SignatureVerificationService;
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use thiserror::Error;
use tokio::sync::{mpsc, oneshot};
use tokio::{runtime::Runtime, sync::broadcast};

type Result<T> = std::result::Result<T, Error>;

pub use crate::{
    configuration::{BeaconConfig, Configuration},
    database::{
        query_language::parameter::{Parameters, ParametersAdd},
        room::Room,
        system_entities::DefaultRoom,
        DataModification, ResultParser,
    },
    event_service::Event,
    log_service::LogService,
    log_service::{Log, LogMessage},
    network::beacon::Beacon,
    security::{base64_decode, base64_encode, derive_pass_phrase, generate_x509_certificate, hash},
};

///
/// Defines every errors that can be by the discret lib
///
///
#[derive(Error, Debug)]
pub enum Error {
    #[error(transparent)]
    Security(#[from] crate::security::Error),

    #[error(transparent)]
    Database(#[from] crate::database::Error),

    #[error(transparent)]
    Network(#[from] crate::network::Error),

    #[error(transparent)]
    Parsing(#[from] crate::database::query_language::Error),

    #[error(transparent)]
    JSON(#[from] serde_json::Error),

    #[error(transparent)]
    TokioJoin(#[from] tokio::task::JoinError),

    #[error(transparent)]
    Timeout(#[from] tokio::time::error::Elapsed),

    #[error(transparent)]
    Bincode(#[from] Box<bincode::ErrorKind>),

    #[error(transparent)]
    Io(#[from] std::io::Error),

    #[error(transparent)]
    OneshotRecv(#[from] tokio::sync::oneshot::error::RecvError),

    #[error(transparent)]
    Synch(#[from] crate::synchronisation::Error),

    #[error(transparent)]
    InvalidAdress(#[from] std::net::AddrParseError),

    #[error("Invalid account")]
    InvalidAccount,

    #[error("An account allready exists")]
    AccountExists,

    #[error("Provider signer is not allowed to sign the datamodel")]
    InvalidSigner(),

    #[error("Application Template cannot be updated with a template with another id")]
    InvalidUpdateTemplate(),

    #[error("tokio send error")]
    SendError(String),

    #[error("{0}")]
    ChannelError(String),

    #[error("Timeout occured while sending {0}")]
    TimeOut(String),

    #[error("Remote Room did not sent back a room definition {0}")]
    RoomUnknow(String),

    #[error("{0} Edges where rejected during synchronisation of room: {1} at date: {2} ")]
    EdgeRejected(usize, String, i64),

    #[error("{0} Nodes where rejected during synchronisation of room: {1} at date: {2}")]
    NodeRejected(usize, String, i64),

    #[error("invalid certificate hash: '{0}'")]
    InvalidCertificateHash(String),

    #[error("Connection to Beacon {0} failed, reason: {1}")]
    BeaconConnectionFailed(String, String),

    #[error("{0}")]
    InvalidConnection(String),

    #[error("{0}")]
    SecurityViolation(String),

    #[error("{0}")]
    InvalidInvite(String),

    #[error("{0}")]
    Unsupported(String),
}

///
/// return the zero filled uid in base bas64
///
pub fn zero_uid() -> String {
    uid_encode(&default_uid())
}
///
/// Verify that the Discret database defined by the parameters exists.
///
pub fn database_exists(
    app_key: &str,
    key_material: &[u8; 32],
    data_folder: &PathBuf,
) -> std::result::Result<bool, Error> {
    GraphDatabaseService::database_exists(app_key, key_material, data_folder)
}

#[derive(Clone)]
pub struct Discret {
    db: GraphDatabaseService,
    peers: PeerConnectionService,
    events: EventService,
    logs: LogService,
    verifying_key: Vec<u8>,
    private_room_id: Uid,
}
impl Discret {
    pub async fn new(
        datamodel: &str,
        app_key: &str,
        key_material: &[u8; 32],
        data_folder: PathBuf,
        configuration: Configuration,
    ) -> std::result::Result<Self, Error> {
        let meeting_secret_key =
            derive_key(&format!("{}{}", "MEETING_SECRET", app_key,), key_material);
        let meeting_secret = MeetingSecret::new(meeting_secret_key);

        let pub_key = meeting_secret.public_key();
        let public_key = pub_key.as_bytes();

        let events = EventService::new();
        let logs = LogService::start();
        let (db, verifying_key, private_room_id) = GraphDatabaseService::start(
            app_key,
            datamodel,
            key_material,
            public_key,
            data_folder.clone(),
            &configuration,
            events.clone(),
            logs.clone(),
        )
        .await?;

        let signature_service = SignatureVerificationService::start(configuration.parallelism);

        let peers = PeerConnectionService::start(
            app_key.to_string(),
            verifying_key.clone(),
            meeting_secret,
            private_room_id,
            db.clone(),
            events.clone(),
            logs.clone(),
            signature_service,
            configuration,
        )
        .await?;

        Ok(Self {
            db,
            peers,
            events,
            logs,
            verifying_key,
            private_room_id,
        })
    }

    ///
    /// Deletion query
    ///
    pub async fn delete(&self, d: &str, p: Option<Parameters>) -> std::result::Result<(), Error> {
        match self.db.delete(d, p).await {
            Ok(_) => Ok(()),
            Err(e) => Err(e.into()),
        }
    }

    ///
    /// mutate
    ///
    pub async fn mutate(
        &self,
        m: &str,
        p: Option<Parameters>,
    ) -> std::result::Result<String, Error> {
        Ok(self.db.mutate(m, p).await?)
    }

    ///
    /// Allow to send a stream of mutation. Usefull for batch insertion as you do have to wait for the mutation to finished before sending another.
    ///
    /// The receiver retrieve an internal representation of the mutation query to avoid the JSON result creation, wich is probably unecessary when doing batch insert.
    /// To get the JSON, call the  MutationQuery.result() method
    ///
    pub fn mutation_stream(
        &self,
    ) -> (
        mpsc::Sender<(String, Option<Parameters>)>,
        mpsc::Receiver<std::result::Result<MutationQuery, crate::database::Error>>,
    ) {
        self.db.mutation_stream()
        // Ok(self.db.mutate(m, p).await?)
    }

    ///
    /// GraphQL query
    ///
    pub async fn query(
        &self,
        q: &str,
        p: Option<Parameters>,
    ) -> std::result::Result<String, Error> {
        Ok(self.db.query(q, p).await?)
    }

    ///
    /// Create an invitation
    /// num_use indicate the number of time it can be used before beiing discarded
    ///   
    pub async fn invite(&self, default_room: Option<DefaultRoom>) -> Result<Vec<u8>> {
        let (reply, receive) = oneshot::channel::<Result<Vec<u8>>>();
        let _ = self
            .peers
            .sender
            .send(PeerConnectionMessage::CreateInvite(default_room, reply))
            .await;
        receive.await?
    }

    ///
    /// Accept an invitation
    ///   
    pub async fn accept_invite(&self, invitation: Vec<u8>) -> std::result::Result<(), Error> {
        let _ = self
            .peers
            .sender
            .send(PeerConnectionMessage::AcceptInvite(invitation))
            .await;

        Ok(())
    }

    ///
    /// This is is your Public identity.
    ///
    /// It is derived from the provided key_material.
    ///
    /// Every data you create will be signed using the associated signing_key, and  
    /// other peers will use this verifying key to ensure the integrity of the data
    ///
    pub fn verifying_key(&self) -> String {
        base64_encode(&self.verifying_key)
    }

    ///
    /// This special room is used internally to store system data
    /// you can use it to query and update the sys.* entities
    ///
    pub fn private_room(&self) -> String {
        base64_encode(&self.private_room_id)
    }

    ///
    /// Subscribe for the event queue
    ///
    pub async fn subscribe_for_events(&self) -> broadcast::Receiver<Event> {
        self.events.subcribe().await
    }

    ///
    /// Subscribe for the log event queue
    ///
    pub async fn subscribe_for_logs(&self) -> broadcast::Receiver<Log> {
        self.logs.subcribe().await
    }

    ///
    /// Update the existing data model definition with a new one  
    ///
    /// returns the JSON representation of the updated datamodel
    ///
    /// can be usefull to create a data model editor
    ///
    pub async fn update_data_model(&self, datamodel: &str) -> std::result::Result<String, Error> {
        Ok(self.db.update_data_model(datamodel).await?)
    }

    ///
    /// Provide a JSON representation of the datamode  
    ///
    /// the JSON contains the model plain text along with the internal datamodel representation
    ///
    /// Can be usefull to create a data model editor
    ///
    pub async fn data_model(&self) -> std::result::Result<String, Error> {
        Ok(self.db.datamodel().await?)
    }
}

struct BlockingRuntime {
    rt: Option<Runtime>,
}
impl BlockingRuntime {
    pub fn new() -> Self {
        Self { rt: None }
    }
    pub fn rt(&mut self) -> std::result::Result<&Runtime, Error> {
        if self.rt.is_none() {
            self.rt = Some(
                tokio::runtime::Builder::new_multi_thread()
                    .enable_all()
                    .build()?,
            );
        }
        Ok(self.rt.as_ref().unwrap())
    }
}

lazy_static::lazy_static! {
    static ref TOKIO_BLOCKING: Arc<Mutex<BlockingRuntime>> =
    Arc::new(Mutex::new(BlockingRuntime::new()));
}
///
/// Provides a blocking API
///
///
#[derive(Clone)]
pub struct DiscretBlocking {
    discret: Discret,
}
impl DiscretBlocking {
    fn new(
        datamodel: &str,
        app_key: &str,
        key_material: &[u8; 32],
        data_folder: PathBuf,
        configuration: Configuration,
    ) -> std::result::Result<Self, Error> {
        let discret = TOKIO_BLOCKING.lock().unwrap().rt()?.block_on(Discret::new(
            datamodel,
            app_key,
            key_material,
            data_folder,
            configuration,
        ))?;

        Ok(Self { discret })
    }

    pub fn delete(&self, d: &str, p: Option<Parameters>) -> std::result::Result<(), Error> {
        TOKIO_BLOCKING
            .lock()
            .unwrap()
            .rt()?
            .block_on(self.discret.delete(d, p))
    }

    pub async fn mutate(
        &self,
        m: &str,
        p: Option<Parameters>,
    ) -> std::result::Result<String, Error> {
        TOKIO_BLOCKING
            .lock()
            .unwrap()
            .rt()?
            .block_on(self.discret.mutate(m, p))
    }

    pub async fn query(
        &self,
        q: &str,
        p: Option<Parameters>,
    ) -> std::result::Result<String, Error> {
        TOKIO_BLOCKING
            .lock()
            .unwrap()
            .rt()?
            .block_on(self.discret.query(q, p))
    }

    pub fn verifying_key(&self) -> String {
        self.discret.verifying_key()
    }

    pub fn private_room(&self) -> String {
        self.discret.private_room()
    }

    pub fn update_data_model(&self, datamodel: &str) -> std::result::Result<String, Error> {
        TOKIO_BLOCKING
            .lock()
            .unwrap()
            .rt()?
            .block_on(self.discret.update_data_model(datamodel))
    }

    pub fn data_model(&self) -> std::result::Result<String, Error> {
        TOKIO_BLOCKING
            .lock()
            .unwrap()
            .rt()?
            .block_on(self.discret.data_model())
    }

    pub async fn subscribe_for_events(&self) -> broadcast::Receiver<Event> {
        TOKIO_BLOCKING
            .lock()
            .unwrap()
            .rt()
            .unwrap()
            .block_on(self.discret.subscribe_for_events())
    }

    pub async fn subscribe_for_logs(&self) -> broadcast::Receiver<Log> {
        TOKIO_BLOCKING
            .lock()
            .unwrap()
            .rt()
            .unwrap()
            .block_on(self.discret.subscribe_for_logs())
    }
}
